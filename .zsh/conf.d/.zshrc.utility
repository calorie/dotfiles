# ------------------------------------
# sudo.vim
# ------------------------------------
sudo() {
  local args
  case $1 in
    vi|vim)
      args=()
      for arg in $@[2,-1]
      do
        if [ $arg[1] = '-' ]; then
          args[$(( 1+$#args ))]=$arg
        else
          args[$(( 1+$#args ))]="sudo:$arg"
        fi
      done
      command vim $args
      ;;
    *)
      command sudo $@
      ;;
  esac
}

# ------------------------------------
# direnv
# ------------------------------------
if command -v direnv >/dev/null 2>&1; then
  eval "$(direnv hook zsh)"
fi

# ------------------------------------
# peco
# ------------------------------------
function peco-select-history() {
  local tac
  if which tac > /dev/null; then
    tac="tac"
  else
    tac="tail -r"
  fi
  BUFFER=$(history -n 1 | \
    eval $tac | \
    peco --query "$LBUFFER")
  CURSOR=$#BUFFER
  zle clear-screen
}
zle -N peco-select-history

function peco-cdr () {
  local selected_dir=$(cdr -l | awk '{ print $2 }' | peco)
  if [ -n "$selected_dir" ]; then
    BUFFER="cd ${selected_dir}"
    zle accept-line
  fi
  zle clear-screen
}
zle -N peco-cdr

function peco-ag () {
  nvim $(ag -S $@ | peco --query "$LBUFFER" | awk -F : '{print "-c " $2 " " $1}')
}
zle -N peco-ag

function peco-git-hash () {
  local hash=$(git log --oneline --branches | peco | awk '{print $1}')
  if [ -n "$hash" ]; then
    BUFFER="${BUFFER} ${hash}"
    zle accept-line
  fi
  zle clear-screen
}
zle -N peco-git-hash

# bindkey -M afu '^G' peco-git-hash
# bindkey -M afu '^R' peco-select-history
bindkey '^G' peco-cdr
# bindkey '^G' peco-git-hash
bindkey '^R' peco-select-history

# ------------------------------------
# misc
# ------------------------------------
function mkcd() { mkdir -p $1 && cd $1; }

# ------------------------------------
# notify for slow commands
# ------------------------------------
# http://qiita.com/hayamiz/items/d64730b61b7918fbb970
# autoload -U add-zsh-hook 2>/dev/null || return
# __timetrack_threshold=30 # seconds
# read -r -d '' __timetrack_ignore_progs <<EOF
#   edf
#   ev
#   fg
#   gdb
#   guard
#   less
#   mosh
#   nc
#   netcat
#   nvim
#   pry
#   rails
#   rl
#   ssh
#   telnet
#   thin
#   tmux
#   top
#   vagrant
#   vi
#   vim
#   xdg-open
# EOF
# export __timetrack_threshold
# export __timetrack_ignore_progs
# function __my_preexec_start_timetrack() {
#   local command=$1
#   export __timetrack_start=`date +%s`
#   export __timetrack_command="$command"
# }
# function __my_preexec_end_timetrack() {
#   local exec_time
#   local command=$__timetrack_command
#   local prog=$(echo $command|awk '{print $1}')
#   local notify_method
#   local message
#   export __timetrack_end=`date +%s`
#   if which growlnotify >/dev/null 2>&1; then
#     notify_method="growlnotify"
#   elif which notify-send >/dev/null 2>&1; then
#     notify_method="notify-send"
#   else
#     return
#   fi
#   if [ -z "$__timetrack_start" ] || [ -z "$__timetrack_threshold" ]; then
#     return
#   fi
#   for ignore_prog in $(echo $__timetrack_ignore_progs); do
#     [ "$prog" = "$ignore_prog" ] && return
#   done
#   exec_time=$((__timetrack_end-__timetrack_start))
#   if [ -z "$command" ]; then
#     command="<UNKNOWN>"
#   fi
#   message="Command finished!\nTime: $exec_time seconds\nCOMMAND: $command"
#   if [ "$exec_time" -ge "$__timetrack_threshold" ]; then
#     case $notify_method in
#       "growlnotify" )
#         echo "$message" | growlnotify -n "ZSH timetracker" --appIcon Terminal
#         ;;
#       "notify-send" )
#         notify-send -i gtk-info "ZSH timetracker" "$message"
#         ;;
#     esac
#   fi
#   unset __timetrack_start
#   unset __timetrack_command
# }
# if which growlnotify >/dev/null 2>&1 ||
#   which notify-send >/dev/null 2>&1; then
#   add-zsh-hook preexec __my_preexec_start_timetrack
#   add-zsh-hook precmd __my_preexec_end_timetrack
# fi
